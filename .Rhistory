x <- rescale(x)
}
# 2. re-normalize data
if (has_attribute(x, "normalized:sum")) {
x <- renormalize(x)
}
# 3. retransform
if (has_attribute(x, "transformed:function")) {
if (!missing(inverse_fun)) {
if (!is_inverse_function(attr(x, "transformed:function"), inverse_fun)) {
stop("fun and fun_inverse are not inverse to each other!")
}
x <- inverse_fun(x)
} else if (has_attribute(x, "transformed:inverse_function")) {
x <- attr(x, "transformed:inverse_function")(x)
} else {
stop("No inverse function found! Please provide either `inverse_fun` or give x an attribute named `transformed:inverse_function`")
}
}
return(x)
}
retransform(y, sqrt)
retransform(y, exp)
x %>% scale %>% rescale()
x %>% normalize %>% renormalize
attr(x, "transformed:function") <- NULL
retransform <- function(x, inverse_fun) {
# 1. rescale data
if (has_attribute(x, "scaled:center") | has_attribute(x, "scaled:scale")) {
x <- rescale(x)
}
# 2. re-normalize data
if (has_attribute(x, "normalized:sum")) {
x <- renormalize(x)
}
# 3. retransform
if (has_attribute(x, "transformed:function")) {
if (!missing(inverse_fun)) {
if (!is_inverse_function(attr(x, "transformed:function"), inverse_fun)) {
stop("fun and fun_inverse are not inverse to each other!")
}
x <- inverse_fun(x)
} else if (has_attribute(x, "transformed:inverse_function")) {
x <- attr(x, "transformed:inverse_function")(x)
} else {
stop("No inverse function found! Please provide either `inverse_fun` or give x an attribute named `transformed:inverse_function`")
}
}
attr(x, "transformed:function") <- NULL
attr(x, "transformed:inverse_function") <- NULL
return(x)
}
x %>% scale %>% rescale()
x %>% transform(fun = log, fun_inverse = exp) %>% retransform
transform(fun = log, fun_inverse = exp)
x %>% transform(fun = log, fun_inverse = exp)
x %>% transform(fun = log, fun_inverse = exp)
x %>% transform(., fun = log, fun_inverse = exp)
is_inverse_function(exp, log)
is_inverse_function(log, exp)
runif(1)
is_inverse_function(exp, log)
is_inverse_function(exp, log)
is_inverse_function(exp, log)
is_inverse_function(exp, log)
is_inverse_function(exp, log)
is_inverse_function(exp, log)
is_inverse_function(exp, log)
is_inverse_function <- function(fun1, fun2) {
x <- runif(1, min = 0.5)
return(fun1(fun2(x)) == x)
}
is_inverse_function <- function(fun1, fun2) {
x <- runif(1, min = 0.5)
return(dplyr::near(fun1(fun2(x)),x))
}
is_inverse_function(exp, log)
x %>% transform(., fun = log, fun_inverse = exp)
x %>% transform(., fun = log, fun_inverse = exp) %>% retransform()
x
x %>% transform(., fun = log) %>% retransform(inverse_fun = exp)
x %>%
transform(., fun = log, fun_inverse = exp, scale = TRUE) %>%
retransform()
x %>%
transform(., fun = log, fun_inverse = exp,normalize = TRUE) %>%
retransform()
sqrt(2) ^ 2 == 2
near(sqrt(2) ^ 2, 2)
library(testthat)
library(usethis)
use_test("transformation")
x <- runif(1:10, min = -1, max = 1)
x
expect_equal(x %>% transform %>% retransform, x)
expect_equal(1,2)
expect_equal(x, x %>%
transform(., fun = log, fun_inverse = exp) %>%
retransform)
x <- runif(1:10, min = 0.01, max = 1)
expect_equal(x %>% scale %>% rescale, x)
expect_equal(x %>% normalize %>% renormalize, x)
x %>% scale %>% rescale
rescale <- function(x, scaling_attributes) {
if (missing(scaling_attributes)) scaling_attributes <- attributes(x)
center <- "scaled:center" %in% names(scaling_attributes)
scale <- "scaled:scale" %in% names(scaling_attributes)
if (isFALSE(center) & isFALSE(scale)) {
warning("Argument x should have attribute `scaled:center` and/or `scaled:scale`")
return(x)
}
if (isTRUE(center) & isTRUE(scale)) {
x_unscaled <- x * scaling_attributes$`scaled:scale` + scaling_attributes$`scaled:center`
} else if (isFALSE(center)) {
x_unscaled <- x * scaling_attributes$`scaled:scale`
} else {
x_unscaled <- x + scaling_attributes$`scaled:center`
}
attr(x_unscaled, "scaled:scale") <- NULL
attr(x_unscaled, "scaled:center") <- NULL
attr(x_unscaled, "dim") <- NULL
return(x_unscaled)
}
expect_equal(x %>% scale %>% rescale, x)
expect_equal(x %>% normalize %>% renormalize, x)
expect_equal(x %>% transform %>% retransform, x)
expect_equal(x, x %>%
transform(., fun = log, fun_inverse = exp) %>%
retransform)
expect_equal(x, x %>%
transform(., fun = log) %>%
retransform(fun_inverse = exp))
x %>%
transform(., fun = log)
retransform
x %>% transform(., fun = log) %>% retransform(inverse_fun = exp)
x
expect_equal(x, x %>%
transform(., fun = log) %>%
retransform(inverse_fun = exp))
x %>%
transform(., fun = log, fun_inverse = exp,normalize = TRUE) %>%
retransform()
expect_equal(x, x %>%
transform(., fun = log, scale = TRUE) %>%
retransform(inverse_fun = exp))
expect_equal(x, x %>%
transform(., fun = log, normalize = TRUE) %>%
retransform(inverse_fun = exp))
# is inverse function
expect_true(is_inverse_function(exp, log))
expect_true(is_inverse_function(log, exp))
expect_true(is_inverse_function(sqrt, function(x)x^2))
build()
library(devtools)
document()
build()
load_all()
a <- runif(10)
library(tidyverse)
a %>% transform(fun = exp, fun_inverse = log) %>% retransform
a
test()
load_all()
test()
document()
build()
library(data.table)
library(tidyverse)
mat <- matrix(runif(1E2), 1E1, 1E1)
mat
mat[sample(1:1E2, 5E1 , replace = FALSE)] <- -Inf
mat
IOvisualize(mat)
loadall
library(devtools)
load_all()
IOvisualize(mat)
library(devtools)
load_all()
vignette("DHARMa", package="DHARMa")
logap <- function(x, a = max(0,-min(x) + eps), eps = 0.001) {
return(log(x + a))
}
logap(1:10)
logap(0:10)
log(0)
logap <- function(x, a = max(0,-min(x) + eps), eps = 0.001) {
cat("a chosen to ", a)
return(log(x + a))
}
logap(0:10)
logap(-2:10)
logap(-10:10)
logap(-10:10) %>% plot
plot(logap(-10:10))
plot(logap(-100:10))
plot(logap(-100:100))
logap <- function(x, a = max(0,-min(x) + eps), eps = 0.001) {
xt <- log(x + a)
attributes(xt) <- list("transformed:function" = function(x) logap(x,a))
return(xt)
}
plot(logap(-100:100))
(logap(-100:100))
logap <- function(x, a = max(0,-min(x) + eps), eps = 0.001) {
xt <- log(x + a)
attributes(xt) <- list("transformed:function" = function(x, a = a) logap(x,a))
return(xt)
}
(logap(-100:100))
logap <- function(x, a = max(0,-min(x) + eps), eps = 0.001) {
xt <- log(x + a)
attributes(xt) <- list("transformed:function" = logap(x,a))
return(xt)
}
(logap(-100:100))
logap <- function(x, a = max(0,-min(x) + eps), eps = 0.001) {
xt <- log(x + a)
attributes(xt) <- list("transformed:function" = function(x) logap(x,eval(a)))
return(xt)
}
(logap(-100:100))
logap <- function(x, a = max(0,-min(x) + eps), eps = 0.001) {
xt <- log(x + a)
attributes(xt) <- list("transformed:function" = function(x, eval = a) logap(x,eval(a)))
return(xt)
}
(logap(-100:100))
logap <- function(x, a = max(0,-min(x) + eps), eps = 0.001) {
xt <- log(x + a)
attributes(xt) <- list("transformed:function" = function(x, a = eval(a)) logap(x,eval(a)))
return(xt)
}
(logap(-100:100))
find_a <- function(x, eps = 0.001) {
return(max(0,-min(x) + eps))
}
(find_a(-100:100))
log(find_a(-100:100))
x <- -10:10
plot(log(x, find_a(x)))
plot(log(x + find_a(x)))
logap <- function(x, a = max(0,-min(x) + eps), eps = 0.001) {
xt <- log(x + a)
attributes(xt) <- list("transformed:function" = logap)
return(xt)
}
logap(-1:10)
logap <- function(x, a = max(0,-min(x) + eps), eps = 0.001) {
xt <- log(x + a)
attributes(xt) <- list("transformed:function" = logap,
"logap:a" = a,
"logap:eps" = eps)
return(xt)
}
logap(-1:10)
bestNormalize::exp_x()
bestNormalize::log_x()
bestNormalize::log_x(1:10, inverse = TRUE)
logap <- function(x, a = max(0,-min(x) + eps), eps = 0.001) {
xt <- log(x + a)
attributes(xt) <- list("transformed:function" = logap,
"logap:a" = a,
"logap:eps" = eps,
"fun" = function(a = eval(a)) a)
return(xt)
}
logap(1:10)
attributes(xt) <- list("transformed:function" = logap,
"logap:a" = a,
"logap:eps" = eps,
"fun" = function(a = print(a)) a)
logap <- function(x, a = max(0,-min(x) + eps), eps = 0.001) {
xt <- log(x + a)
attributes(xt) <- list("transformed:function" = logap,
"logap:a" = a,
"logap:eps" = eps,
"fun" = function(a = print(a)) a)
return(xt)
}
logap(1:10)
logap <- function(x, a = max(0,-min(x) + eps), eps = 0.001) {
xt <- log(x + a)
attributes(xt) <- list("transformed:function" = logap,
"logap:a" = a,
"logap:eps" = eps,
"fun" = function(a = print(a)) quote(a))
return(xt)
}
logap(1:10)
attributes(xt) <- list("transformed:function" = logap,
"logap:a" = a,
"logap:eps" = eps,
"fun" = function(a = quote(a)) quote(a))
logap <- function(x, a = max(0,-min(x) + eps), eps = 0.001) {
xt <- log(x + a)
attributes(xt) <- list("transformed:function" = logap,
"logap:a" = a,
"logap:eps" = eps,
"fun" = function(a = quote(a)) quote(a))
return(xt)
}
logap(1:10)
a <- 0.2
eval(function(x) x + a)
(function(x) x + a)
eval(quote(function(x) x + a))
function(x) x + eval(quote(a))
eval(a)
eval(quote(a))
whisker::whisker.render(template = "function(x) logap(x, a = {{a}})",
data = list("a" = a))
as.function(whisker::whisker.render(template = "function(x) logap(x, a = {{a}})",
data = list("a" = a)))
function(whisker::whisker.render(template = "function(x) logap(x, a = {{a}})",
data = list("a" = a)))
(whisker::whisker.render(template = "function(x) logap(x, a = {{a}})",
data = list("a" = a)))
parse(whisker::whisker.render(template = "function(x) logap(x, a = {{a}})",
data = list("a" = a)))
eval(parse(whisker::whisker.render(template = "function(x) logap(x, a = {{a}})",
data = list("a" = a))))
(get(whisker::whisker.render(template = "function(x) logap(x, a = {{a}})",
data = list("a" = a))))
(assign(whisker::whisker.render(template = "function(x) logap(x, a = {{a}})",
data = list("a" = a))))
((whisker::whisker.render(template = "logap(x, a = {{a}})",
data = list("a" = a))))
(eval(whisker::whisker.render(template = "logap(x, a = {{a}})",
data = list("a" = a))))
(quote(whisker::whisker.render(template = "logap(x, a = {{a}})",
data = list("a" = a))))
((whisker::whisker.render(template = quote("logap(x, a = {{a}})"),
data = list("a" = a))))
((whisker::whisker.render(template = ("logap(x, a = {{a}})"),
data = list("a" = a))))
body <- "(x1 + x2) * x3"
args <- "x1, x2, x3"
eval(parse(text = paste('function(', args, ') { return(' , body , ')}', sep='')))
eval(parse(text = whisker::whisker.render(template = ("function(x) logap(x, a = {{a}})"),
data = list("a" = a))))
#' @param fun a function to transform x
#' @param fun_inverse the inverse of it
#' @param scale boolean. shall x also be scaled? default = FALSE
#' @param normalize boolean. shall x also be normalized? default = FALSE
#' @param ... other parameters passed `scale` (at the moment only support `center`)
#'
#' @return
#' @export
#'
#' @examples
transform <- function(x, fun, fun_inverse,
scale = FALSE, normalize = FALSE, eps = 0.001, ...) {
if (fun == "logap") {
a <- max(0,-min(x) + eps)
fun <- eval(parse(text = whisker.render(template =
("function(x) logap(x, a = {{a}}, eps = {{eps}})"),
data = list("a" = a,
"eps" = eps))))
fun_inverse <- function(x) exp(x) - a
}
if (!missing(fun)) {
x <- fun(x)
attr(x, "transformed:function") <- fun
if (missing(fun_inverse)) {
attr(x, "transformed:inverse_function") <- NULL
} else {
if (is_inverse_function(fun, fun_inverse)) {
attr(x, "transformed:inverse_function") <- fun_inverse
} else stop("fun and fun_inverse are not inverse to each other!")
}
}
if (isTRUE(scale) & isTRUE(normalize)) stop("scaling and normalization together does not make any sense. Please set either scale=FALSE or normalize=FALSE")
if (isTRUE(scale)) {
atts <- attributes(x)
x <- scale(x, ...)
attr(x, "dim") <- NULL
attributes(x) <- c(atts, attributes(x))
}
if (isTRUE(normalize)) x <- normalize(x)
return(x)
}
transform(-1:10, fun = "logap")
library(whisker)
transform(-1:10, fun = "logap")
library(devtools)
load_all()
transform(-1:10, fun = "logap")
load_all()
transform(-1:10, fun = "logap")
#' @param fun a function to transform x
#' @param fun_inverse the inverse of it
#' @param scale boolean. shall x also be scaled? default = FALSE
#' @param normalize boolean. shall x also be normalized? default = FALSE
#' @param ... other parameters passed `scale` (at the moment only support `center`)
#'
#' @return
#' @export
#'
#' @examples
transform <- function(x, fun, fun_inverse,
scale = FALSE, normalize = FALSE, eps = 0.001, ...) {
if (fun == "logap") {
a <- max(0,-min(x) + eps)
fun <- eval(parse(text = whisker.render(template =
("function(x) logap(x, a = {{a}})"),
data = list("a" = a))))
fun_inverse <- eval(parse(text = whisker.render(template =
("function(x) exp(x) - {{a}}"),
data = list("a" = a))))
}
if (!missing(fun)) {
x <- fun(x)
attr(x, "transformed:function") <- fun
if (missing(fun_inverse)) {
attr(x, "transformed:inverse_function") <- NULL
} else {
if (is_inverse_function(fun, fun_inverse)) {
attr(x, "transformed:inverse_function") <- fun_inverse
} else stop("fun and fun_inverse are not inverse to each other!")
}
}
if (isTRUE(scale) & isTRUE(normalize)) stop("scaling and normalization together does not make any sense. Please set either scale=FALSE or normalize=FALSE")
if (isTRUE(scale)) {
atts <- attributes(x)
x <- scale(x, ...)
attr(x, "dim") <- NULL
attributes(x) <- c(atts, attributes(x))
}
if (isTRUE(normalize)) x <- normalize(x)
return(x)
}
transform(-1:10, fun = "logap")
load_all()
transform(-1:10, fun = "logap")
test <- transform(-1:10, fun = "logap")
attr(test, "transformed:function")
load_all()
test <- transform(-1:10, fun = "logap")
attr(test, "transformed:inverse_function")
environment(attr(test, "transformed:inverse_function"))
environment(attr(test, "transformed:inverse_function")) <- NULL
attr(test, "transformed:inverse_function")
attr(test, "transformed:inverse_function")(4)
environment(attr(test, "transformed:inverse_function")) <- NA
?environment
test <- transform(-1:10, fun = "logap")
attr(test, "transformed:function")
attr(test, "transformed:function")(3)
document()
build()
load_all()
document()
build()
source('~/Documents/code/R/my.utils/R/general_tools.R')
document()
build()
load_all()
x <- -1:10
my.utils::transform(x, fun = "logap")
x[5] <- NA
my.utils::transform(x, fun = "logap")
load_all()
my.utils::transform(x, fun = "logap")
#' see ?bestNormalize::log_x()
#'
#' @param x
#' @param a
#' @param eps
#'
#' @return
#' @export
#'
#' @examples
logap <- function(x, a = max(0,-min(x, na.rm = TRUE) + eps, na.rm = TRUE),
eps = 0.001) {
xt <- log(x + a)
attributes(xt) <- list("transformed:function" = logap,
"logap:a" = a,
"logap:eps" = eps)
return(xt)
}
document()
build
build()
my.utils::transform(x, fun = "logap")
load_all()
my.utils::transform(x, fun = "logap")
load_all()
my.utils::transform(x, fun = "logap")
load_all()
my.utils::transform(x, fun = "logap")
load_all()
my.utils::transform(x, fun = "logap")
load_all()
my.utils::transform(x, fun = "logap")
load_all()
my.utils::transform(x, fun = "logap")
load_all()
load_all()
my.utils::transform(x, fun = "logap")
document()
build
build()
load_all()
x <- -1:10
x[5] <- NA
my.utils::transform(x, fun = log)
# calculate Leontief inverse
I_mat <- diag(rep(1, nrow(A)))
diag(20)
